
Import av Trafikverkets NVDB-data till OpenStreetMap
----------------------------------------------------

Detta är README-filen till nvdb2osm.py, ett skript som konverterar
nedladdat NVDB-data (i SHP-format) till en OSM XML-fil.

Det körs på kommandoraden:

nvdb2osm.py <katalog eller zip-arkiv med NVDB shape-filer> <output.osm>

Exempel:

nvdb2osm.py -v Vilhelmina_kommun_Shape_TNE__9343.zip vilhelmina.osm

Kör kommandot utan argument för att se vilka flaggor man kan sätta. I
exemplet används "-v" för att visa INFO-loggar.

Det tar cirka en kvart att tugga igenom en kommun. Arkiven med
shape-filer laddas ner från Trafikverket. Man går till
https://lastkajen.trafikverket.se/ om man inte har ett konto finns det
knapp att registrera sig där.

Väl inne går man till Fillager->Vägdata->Kommuner/Län Shape och så
väljer man län och kommun. Det går ladda ner hela län om man vill, men
det blir orimligt mycket data att tugga på en gång.

Det går att köra skriptet direkt på zip-arkivet man laddar ner, det är
inte nödvändigt att packa upp det, men även det fungerar.

Skriptet kräver vissa tredjepartsmoduler, listade i requirements.txt,
installera med pip install -r requirements.txt

För generell Python-användning och installation får man Googla :-)


Tips för Windows 10-installation
--------------------------------

Anaconda för python gör det enklare.

    conda install geopandas
    conda install sortedcontainers
    pip install scanf


Hur importen går till
---------------------

1. Ladda ner paketerat NVDB-data från https://lastkajen.trafikverket.se/
2. Konvertera datat till OSM-format med Python-skriptet
3. Ladda in resultatet som ett eget lager i JOSM
4. Ladda ner existerande OSM-karta för motsvarande område till eget
   lager i JOSM
5. Förbered existerande OSM-data för att sammanfogas med NVDB
6. Sammanfoga lagren, och ladda upp

Att ladda ner och köra det här skriptet är ett litet jobb, det stora
jobbet är att sammanfoga det manuellt med existerande. Har man inte
möjlighet/kunskap att köra Python-skript kan man kanske be någon annan
köra skripet för det område man är intresserad av för att få en
OSM-fil som man sen kan jobba med.
Bakgrund
--------

När OSM startades var det inte vanligt att det fanns publika data av
den kvalitet som finns idag i många länder. Tanken var att en stor
mängd frivilliga skulle manuellt rita alla vägar baserat på flygfoton
och egna GPS-spår.

Idag används de traditionella manuella teknikerna parallellt med att
man importerar data från olika publika databaser. Importer är
internationellt sett ett känsligt ämne, då många inom OSM fortfarande
tycker att databasen endast borde innehålla manuellt arbete gjort av
oss själva. Delvis på grund av det finns det fortfarande inga
funktioner i OSM för att använda externa datakällor och automatisk
synkronisera dessa när de uppdateras.

Det innebär att importer är fortfarande till stor del ett manuellt
arbete, och varje typ av import blir ett litet utvecklingsprojekt i
sig.

Notera att tanken med import är inte att ersätta manuellt
kartläggande, utan att vara ett komplement. Antalet kartläggare i
Sverige idag är inte tillräckligt för att hålla hela landet
uppdaterat, men genom att importera en bra bas blir arbetsuppgiften
för manuell kartläggning mer rimlig.

NVDB innehåller inte allt man vill kartlägga heller, elljusspår, olika
stigar, mm finns inte, så manuell kartläggning med lokal kännedom är
fortsatt viktig och central.


Om NVDBs precision
------------------

De flesta av våra vägar finns redan i OSM, men många är kartlagda för
många år sedan när datakällorna inte var lika bra som NVDB är, så de
är ofta värda att uppdatera.

NVDB-datat om än bra är inte 100% perfekt. "Värsta" exemplet är bro-
och tunneldatat som uppvisar en hel del precisionsfel, i enstaka fall
kan en bro ligga flera hundra meter fel. I andra fall handlar det mer
om hur man väljer att kartlägga vid begränsat utrymme: inne i städer
där cykelvägar och vägar kartläggs nära bredvid varandra läggs de inte
alltid exakt geografiskt utan på ett sätt som ger vägarna mer
utrymme.

NVDB-datat innehåller också flera överlapp och små glapp här och var,
vilket gör det besvärligt att jobba med maskinellt, men de flesta av
dessa småfel hanteras och repareras av importskriptet.

Hursomhelst, överlag är NVDB en mycket bra datakälla med bra
precision, så man behöver i regel inte korrigera vägarna efter
flygfoton, utan snarare tvärtom kan man använda NVDB-vägarna för att
justera flygfotons position.


Om NVDBs data-taggar
--------------------

OSM har all information i samma geometri genom att man sätter en mängd
taggar på varje väg/nod. NVDB är istället organiserat i lager med
olika information, underliggande geometri är dock
densamma. Hastighetsgränser ligger i ett lager, vägnamn i ett annat
och så vidare.

Importskriptet tar alltså alla dessa lager, översätter taggarna lager
för lager och sammanfogar. Ibland överlappar information och skripet
försöker lösa dessa situationer automatiskt, vilket går i de flesta
fall. Om inte skrivs det ut en varning och en "fixme"-tag skrivs in i
resulterande OSM-fil så man kan gå in och justera manuellt.

(NVDB:s Shape-filer (.shp) går att öppna direkt i JOSM, vilket är
användbart om man vill jämföra. JOSM gör viss geometriförenkling och
tar bort dubletter när den öppnar en Shape-fil, så håller man på
debugga sådant behöver man analysera datat på annat vis.)

NVDB har med få undantag en hög grad av korrekthet i informationen, så
den går överlag lita på när man inte har någon bättre information.
För nybyggnationer kan datat dock vara inaktuellt och där kan det
saknas geometri. Ibland kan vissa lager ha ny information och andra
lager har gammal, och då kan det bli det problem i sammanfogningen,
normalt lyckas dock skriptet tugga igenom datat ändå.

Enskild väg har inte lika rik information eftersom den inte underhålls
statligt. Vägbeläggning sägs vara grus även om vägföreningen lagt
asfalt till exempel. I vissa (sällsynta) fall kan vägar vara så dåligt
underhållna att de inte längre är framkomliga för bilar. Där är
flygfoton och lokal kännedom till hjälp.

Många av NVDB:s taggar går att översätta mer eller mindre rakt av till
en motsvarande OSM-tag. I vissa fall har dock NVDB mer information än
vad OSM har taggar för (till exempel fordon- och trafikanttyp), och i
andra fall har NVDB mindre information än vad OSM förväntar sig
(körfältens riktning på flerfiliga vägar och vilket av flera körfält
som är för kollektivtrafik).

I ett flertal fall finns det olika tänkbara översättningslösningar,
för att se hur skriptet gör får man läsa koden.


Kommentar om NVDB:s RLID och segmentlängd
-----------------------------------------

NVDB:s geometri har globalt unika identifierare "RLID". Dessa är
statiska och förändras inte, så man kan spåra vad som hänt med en
väg. I tidiga versioner av det här skriptet så fördes dessa
över. Vägsegmenten med ett RLID är emellertid i många fall korta,
vilket gör att vägarna blir upphuggna i små bitar. Ofta sammanfaller
det med broar, ändring av hastighetsgränser osv (som gör att det blir
uppdelning även i OSM) så i många fall blir det ändå inte fler bitar
än vad det skulle vara annars.

Testing visade dock att det är tillräckligt ofta en väg blir upphuggen
i småbitar enbart pga av RLID så därför har vi plockat bort
det. Skriptet genererar nu så långa segment som möjligt, dvs så länge
vägen inte ändrar taggar sitter det ihop i ett segment.

Trots detta blir segmenten ofta kortare än vad som finns inne i OSM nu
eftersom NVDB-skriptet har ofta högre detaljnivå (broar, ändrade
hastighetsgränser mm) som gör att taggar byts och vägarna måste delas
upp av den anledningen.

Att RLID inte förs över innebär vissa nackdelar när man ska göra
framtida uppdatering av datat. Ett uppdateringsskript måste emellertid
oavsett RLID eller ej gå in och jämföra geometrin med avancerade
algoritmer eftersom datat lever tillsammans med manuellt ritad
geometri och andra datakällor, så RLID gör inte mycket till eller från
i praktiken. I vissa specialfall hade det förvisso varit en bonus att
ha RLID kvar, men vi har gjort bedömningen att det är viktigare att
göra så långa segment som möjligt.


Tips för att sammanfoga med existerande data
--------------------------------------------

Att sammanfoga ett nytt OSM-lager som detta skript genererar med
existerande kartdata i OSM är en ganska avancerad uppgift, och det
hjälper om man är van att använda JOSM innan man försöker.

Tipsen på arbetsflöde som ges här utgår från att man går igenom "allt"
inom ett visst område. Men man behöver inte uppdatera all geometri om
man inte vill förstås, man kan plocka ut mindre delar. Det handlar
dock inte bara om geometrin, NVDB-lagret innehåller väldigt mycket
taggar, hastighetsgränser, trafikförbud med tidsintervall osv osv ofta
mycket mer än vad som finns kartlagt sedan tidigare, åtminstone på
landsbygden. Därför kan det vara värdefullt att uppdatera vägar även
om de redan finns och ligger någorlunda rätt positionerade.

Det är också väldigt vanligt att vägar kan vara väl positionerade på
ett ställe, och på ett annat ställe längs samma väg ligger den 50
meter fel, så det kan löna sig att gå igenom hela vägsträckan.

Förbehandling:

Förbehandla översatt OSM-lager först. Gå igenom alla fixme-taggar och
kör JOSM-validatorn. Tips om detta finns under separat rubrik.

Välj ut område att jobba i:

Vissa delar i Sverige, exempelvis Stockholm, är redan idag mycket väl
uppdaterad i OSM. Välj ut delar som har större behov av uppdatering
först, och är du nybörjare börja med en mindre komplex geometri
(landsbygd istället för stad). I städer behöver mer förbehandling av
översatt OSM-lager göras, och det finns mer tolkning av hur
kartläggning ska göras (mappa cykelvägar separat eller ej, och hur de
exakt placeras i förhållande till intilliggande väg) och det finns mer
av avancerade relationer att ta hänsyn till (busslinjer etc) - det är
helt enkelt mycket gånger svårare att jobba med stadsgeometri än
landsbygd.

Se till att du jobbar på ett ställe på kartan där ingen annan håller
på just nu. Det kan nämligen bli väldigt besvärligt om två personer
håller på och redigerar kartan på samma ställe. Använd exempelvis
history-funktionen på openstreetmap.org så kan de se var folk jobbar
just nu. Försök också jobba i mindre bitar så du kan ladda upp samma
dag som du laddade ned för att redigera, ju kortare tid mellan ned-
och uppladdning desto mindre risk för kollisioner med andras arbete.

Man kan använda webb-verktyget http://overpass-turbo.eu för att göra
taggsökningar, exempelvis på "source=NVDB" för att se var i kartan
NVDB-information använts.

Kontrollera positionen av existerande data:

Vissa delar av kartan är senast uppdaterad när positionsdatat i
tillgängligt källmaterial var mindre exakt, man kan därför hitta stora
områden som är ganska detaljerade men som har ett offset på ett antal
tiotals meter. I vissa fall är positionsfelet så stort att man först
måste korrigera det innan man börjar arbeta med att sammanfoga, annars
kommer de exakta NDVB-vägarna gå rakt över lantbruk, sjöar och
byggnader osv. Gör då offset-korrigeringen i en separat förändring och
ladda upp innan du börjar jobba med importen.

Modifiera inte geometrin i onödan, men gör det om du måste:

För att underlätta för framtida uppdateringar av NVDB-datat så bör man
inte modifiera NVDB-geometrin om det inte är nödvändigt. Om vägarna
ändrar form blir det svårare för ett uppdateringsskript att
matcha. Ibland måste man ändra för att spegla vad som faktiskt hänt i
verkligheten och det är okej förstås. Då det gäller specifikt broar så
ligger de ofta lite fel i NVDB och då måste man ju flytta dem.

Välj ut en lagom stor area och sammanfoga:

Man översätter typiskt en kommun i taget med skriptet, men även en hel
kommun kan bli mycket att jobba med. Man kan därför vilja dela upp
den, genom lite copy/paste mellan lager. Att aktivera ett nodfilter
kan göra copy/paste mellan lager enklare.

När du sen har ett lagomt stort NVDB-lager laddar du ner tillräckligt
mycket karta från OSM så hela NVDB-lagret är täckt. Därefter
sammanfogar du NVDB-lagret på det nedladdade datat (det kan vara smart
att behålla en kopia av NVDB-lagret som referens).

Det man nu har är en enda röra :-), två kartlager på varandra, det som
finns i OSM-databasen nu, plus NVDB-lagret. Det går ta bara en väg åt
gången om man känner sig mer bekväm med det, men detta sätt är i regel
effektivare. Ju mer man jobbar desto duktigare blir man på se skillnad
mellan gammal och ny geometri och det blir mindre förvirrande att
jobba, men i början kommer det vara lite grötigt.

JOSM har en bra validator som upptäcker om man har vägar som ligger
ovanpå eller nästan ovanpå varandra, det gör att det är mycket låg
risk att man glömmer jobba igenom och sammanfoga över hela kartan.

Använd replace geometry för att uppdatera geometri:

Om du inte redan installerat "utilsplugin2" i JOSM så gör det, för du
behöver verktyget "replace geometry". För ett uppdatera en gammal väg
med ny NVDB-geometri, gör så här:

0. Grundprincipen att följa är att varenda segment i NVDB-vägen måste
   göras replace geometry mot ett motsvarande segment i gamla
   vägen. Om inte riskerar man att bli av med taggar som fanns i gamla
   vägen för vissa segment. I de flesta fall har gamla vägen färre
   segment (saknas broar, färre taggar osv), och då måste man dela upp
   gamla vägen i motsvarande segment.
1. Markera NVDB-vägen och se hur långt segmentet är, markera
   motsvarande segment i gamla vägen.
2. Om den gamla vägen har ett mycket längre segment (perfekt passning
   inte nödvändigt), klipp upp den. OBS: klipp av på existerande nod,
   lägger man till en ny nod blir "replace geometry"-verktyget
   förvirrat (i skrivande stund åtminstone).
    - Var uppmärksam när du närmar dig slutet av vägen så inte segment
      i gamla vägen tar slut innan du gjort replace geometry med alla
      NVDB-segment.
    - Om den gamla vägen istället har fler segment, dela upp
      NVDB-segmentet på motsvarande vis. Om möjligt gör join på
      vägarna efter replace geometry gjorts (dvs om taggarna är precis
      samma i båda segmenten).
    - Var speciellt uppmärksam på broar (och tunnlar), NVDB har
      ganska ofta precisionsproblem i placeringen av dessa så man kan
      behöva justera dem manuellt.
3. Gör replace geometry, och lös eventuella tag-konflikter i dialogen
   som kommer upp.
    - Ibland har gamla vägen en relation (större vägar har oftast
      det), dessa ska behållas.
4. Upprepa segment för segment tills hela vägen är ersatt.

"Replace geometry" gör att ersättningen av den gamla geometrin görs
med modify-operationer (dvs det ser ut som man manuellt flyttat och
lagt till noder i den gamla vägen så att den exakt matchar den
nya). Detta gör att historyn av vägsegmentet behålls vilket är viktigt
för att kunna spåra förändringar, och visar respekt mot de kartläggare
som ritat vägen innan.

Om vägen man ersätter innehåller noder med taggar, som till exempel
övergångsställe osv, så går det inte göra replace. Man måste då
kopiera över dessa nodtaggar. Därefter går det att göra replace
geometry som vanligt. Ofta finns noderna redan representerade i
NVDB-vägen, om det är övergångsställen till exempel, men då det gäller
exempelvis vändplaner (highway=turning_circle) saknas de ofta i NVDB.

Var upmärksam på tidigare taggar och relationer:

I vissa fall kan det vara så att tidigare kartläggning har en högre
detaljnivå på taggningen än vad importerade datat har. Red ut dessa
efter eget omdöme, ibland kan man behöva behålla det som redan finns,
och kanske dela upp NVDB-datat i fler segment för att matcha. Följ
replace-geometry-metoden ovan så går man automatiskt igenom alla
segment.

Det här import-skriptet skapar inga relations-objekt. Busslinjer,
landsvägar etc finns ofta redan inlagda som relationer, se till att
dessa behålls och kopplas ihop korrekt. Genom att använda replace
geometry-arbetsflödet så sköts det automatiskt.

Hantera kanter:

När man konverterar en del i taget så kommer förstås vägar längs
kanterna på området man jobbar med vara avhuggna. Det kan vara
frestande att låta dem vara okopplade eftersom man snart ska ta in
nästa del, men för att inte hamna i en situation med en trasig karta
uppladdat till OSM se till att koppla ihop vägarna längs kanterna med
existerande vägar (om de finns). Justera de existerande vägarna
istället för NVDB-vägarna, så när man tar in nästa del passar de
ihop.

Var uppmärksam på vägtyper, modifiera vid behov:

För stora vägar har NVDB bra information, men för kommunal och enskild
väg är den mer begränsad. I industrisammanhang kanske en väg blir
residential fastän den hellre borde vara t ex service. Småvägar till
sommarstugor ute på landsbygden blir ofta "highway=track" baserat på
NVDB-datat, en del väljer kartlägga dessa som service eller liknande.

Validatorn är din vän:

Crossing highways, disconnected ways osv. Gå igenom varningarna
ordentligt och lär dig vad de betyder. Den är bra på att upptäcka om
du har vägdubletter eller vägar som inte är hopkopplade.


FIXME-taggar och JOSM Validator
-------------------------------

Skriptet lägger till fixme-taggar där det inte klarar av att lösa en
konflikt eller där NVDB inte ger tillräckligt med information. Dessa
måste man gå igenom och lösa manuellt. Använd JOSMs sökfunktion och
sök på fixme=* för att få fram all geometri som är taggad.

När skripet körs loggar den till konsollen och skriver ut "Warning:
...." när den stöter på något problem. Det kan vara bra att titta på
dessa. Oftast resulterar en Warning i en fixme-tagg i datat så det är
inte alldeles nödvändigt att gå igenom loggen.

Man *måste* använda JOSM Validator på OSM-filen för att se vilka
problem den upptäcker, och åtgärda manuellt vid behov. I stadsmiljöer
kan det vara ganska mycket som behöver manuell justering, på
landsbyggden ibland ingenting. Bro- och tunneldatat i NVDB har en del
begränsningar och precisionsproblem, kanske saknas en cykelbro osv.

(När man håller på och bollar med lager i JOSM så slutar ibland
Validator köra och visar istället ett gammalt resultat. För att tvinga
den att köra om, markera alla objekt du vill verifiera och tryck på
validator-knappen.)

Exempel på vanliga Validator-varningar, med kommentarer:

 - Barrier=yes is unspecific:
    - Begränsad NVDB-information. Kanske kan du förbättra genom
      flygfoto
 - Crossing highways:
    - Beror ofta fel/begränsningar i NVDB:s bro- och tunneldata,
      ibland saknas broar helt och hållet osv.
 - Missing tag - street with odd number of lanes:
    - På dubbelriktad väg med fler än två filer innehåller inte NVDB
      någon information om hur många filer som går i vardera
      riktning. Det går i regel lista ut från flygfoto.
 - Stub end:
    - Skriptet städar upp stumpar genom att länka ihop segment så
      långa som möjligt och ta bort små glapp, så de som ändå blir
      kvar bör man i regel lämna orörda.
 - Suspicious tag combination oneway=yes with lanes:bus:forward:
    - Felakting varning(?), att ange riktning på lanes även om vägen
      är enkelriktad verkar vara okej enligt OSM-wiki
    - Skriptet filtrar bort onödiga forward/backward i andra fall när
      vägen är enkelriktad, men behåller på lanes.
 - Way end node near other highway:
    - Kan nästan alltid ignoreras, handlar ofta om hållplatser som
      rätteligen slutar nära en annan väg
 - Overlapping highways / highway duplicated nodes / highways with
   same position:
    - I sällsynta fall har NVDB vägar med olika RLID som ligger ovanpå
      varandra. Det är så sällsynt så skripet har ingen korrigering
      för det, om det uppstår får man laga det manuellt.
 - Suspicious roundabout direction:
    - Vissa rondeller är inte helt runda och då kan JOSM tro att de
      har felaktigt taggats som rondeller. Denna varning kan man i
      regel ignorera.


Övrigt att tänka på
-------------------

Vägnummer:

I Sverige är vi vana att europavägar skrivs utan mellanslag, "E4"
istället för "E 4". För att hålla en OSM-standard över hela Europa så
genererar skriptet dock "E 4", och detta bör behållas. Länsvägar
100-499 är unika och skrivs utan länsbokstav. Länsvägar över 500 är
inte unika och därtill läggs länsbokstav (exempel "AC 1100" istället
för bara "1100"). I officiella sammanhang används länsbokstav endast
om det är nödvändigt för att undvika sammanblandning. Eftersom det ska
gå att söka i OSM-datat är det viktigt att taggar är unika därför ska
länsbokstaven vara med här.

Undernummer används sällan i olika kartor, men det finns med i OSM nu
och skriptet tar därför med dem läggs på efter huvudnumret separerat
med en punkt, exempel ("E 4.20").

Vägklass:

Skriptet använder funktionell vägklass med flera lager för att räkna
ut om en väg ska vara trunk/primary/tertiary och så vidare. Oftast
stämmer det överens med tidigare kartlagt, men inte alltid. När det
inte stämmer är det ofta(st) bättre att behålla det som redan är
kartlagt, även om vägen kan vara kartlagd med begränsad precision
innan är typen ofta rätt. På mindre vägar
(residential/unclassified/track) saknar NVDB detaljerad information,
så där kan man behöva manuellt ändra till service etc. För skogsvägar
är gränsen mellan unclassified och track lite knepig. Det kan finnas
anledning att nedgradera unclassified till track eller tvärtom på
vissa ställen för att bättre följa OSM-kartläggningstradition (för
skogsväg tittar funktionsklassen en del på vägkvalitet för lastbilar
osv, medan OSM tittar mer på hur mycket vägen används för vanlig
trafik).

Betraktar man lantmäteriets rasterkarta kan man ibland se att de har
mer information om småvägar än vad skriptet har, och det beror på att
rasterkartan just har mer vägklassinformation än vad som publicerats
via NVDB. Ett exempel är att rasterkartan kan göra en skogsväg
streckad, medan NVDB sätter den till unclassified som tyder på en
högre underhållsgrad. I det fallet bör man ändra till track, men kolla
flygfoto och förbindelser först. Finns det en tidigare väg innan ska
man förstås behålla dess taggar om man inte är säker på att man gör en
bra ändring.

Vägbeläggning:

NVDB specar endast "belagd" eller "grus" för kommunala och enskilda
vägar (mer detaljerat för statligt underhållna vägar). "Grus" är ett
antagande och hamnar även på jordvägar mm, därför sätter skriptet
"surface=unpaved" för dessa vägar. För "belagd" är sannolikheten så
hög att det är någon form av asfalt att surface=asphalt används. För
kullersten mm får man således ändra manuellt.

(I OSM idag är "surface=gravel" vanlig som beteckning på grusvägar,
men enligt OSM-wiki avser det knytnävsstora stenar, så egentligen inte
rätt. Bättre är då "surface=fine_gravel".)

Vägbommar:

Bommar som NVDB markerat med "låst grind eller bom" sätts till
barrier=gate med access=permissive. Det betyder att bommen är
generellt sett öppen, men den kanske inte är det. Om man vet att
bommen är i regel låst kan man ändra taggen till access=private (det
finns också locked=yes, men den taggen är mindre använd).

Geometriförenkling:

NVDB:s geometri har väldigt många punkter för att göra så mjuka kurvor
som möjligt. I OSM är det mesta handritat och därför är det
traditionellt färre punkter. Många punkter gör det också besvärligare
att göra manuell uppdatering och långsammare att jobba i de verktyg
som finns. Därför förenklas geometrin innan den sparas för att mer
efterlikna OSM:s tradition. Det är inte samma nivå av förenkling
överallt, fler punkter behålls i rondeller än på landsväg till
exempel. Vill man se hur geometrin ser ut före förenkling kan man
använda --dump_layers-flaggan och kika på debug-lagren skriptet då
sparar.


Hålla datat uppdaterat
----------------------

NVDB är en levande databas och uppdateras hela tiden. Tanken med OSM
är att det ska finnas tillräckligt många frivilliga som håller datat
uppdaterat genom manuell kartläggning utan att behöva synka med någon
extern databas som NVDB. I praktiken finns inte så många aktiva
kartläggare i Sverige, men med NVDB inmatad i grunden finns ändå en
god chans att hålla datat fräscht på traditionellt vis - vägnätet är
ju ändå ganska statiskt. Så även om vi bara tar in NVDB-datat en gång
så lämnar i OSM-kartan i en bättre situation än den var innan.

Det finns ingen funktion i OSM för att synka automatiskt med externa
databaser, så att göra en uppdatering i framtiden skulle antagligen gå
till som så att man använder detta skript och konverterar det senaste
NVDB-datat, sen skriver man ett nytt skript som jämför detta med data
som finns inne i OSM, och därefter genererar en skillnadsfil (diff)
som man manuellt får föra över. Detta skulle man kanske göra en gång
varannat år eller så, för att komplettera sådant som kartläggare inte
hunnit uppdatera manuellt.

Detta nya skript blir troligen ganska svårt att skriva eftersom man
helst vill att det ska kunna filtrera bort justeringar i datat som
inte är faktiska förändringar utan bara förfiningar eller tillägg till
NVDB-datat, för att göra skillnadsfilen så liten som möjligt.


Information om koden
--------------------

Denna information kan bli snabbt inaktuell i och med att koden
uppdateras.

Koden är överlag ett "snabbhack", fokus på att få fram något som
fungerar så fort som möjligt snarare än att producera snygg effektiv
kod och design. Hade jag börjat om från början skulle jag troligen
försöka använda mer av shapely-biblioteket för att få effektivare
kod. Eftersom det mesta av geometriberäkningarna görs i Python-kod är
skriptet ganska långsamt.

Testning inför första release har bestått av att översätta Malmö,
Göteborg, stor-Stockholm, Umeå, Uppsala, Jokkmokk och Luleå. Även om
dessa täcker in väldigt många fall och olika typer av knepigheter i
NVDB-datat så är det troligt att skriptet kommer behöva kompletteras
ytterligare för att kunna översätta all NVDB-data i hela Sverige.

För att spara tid i bästa snabbhacksanda kör geometrikoden en massa
integritetstest på det egna datat efter förändringar, som alternativ
till en stor mängd enhetstest. Det gör att skriptet går långsammare än
det annars skulle göra. Om man orkar kan man fixa det senare (dvs ta
bort integritetstesterna och göra enhetstest på sidan om istället).

Det finns en .pylintrc så man kan köra pylint på koden.

nvdb2osm.py:

Här finns main(), alltså huvudfunktionen som kör hela processen. Grovt
sett funkar det så här:

1. Läs in ett lager med referensgeometrin och skapa en datastruktur
med denna som alla efterföljande lager matchas mot.

2. Läs in alla lager med linjegeometri, ett i taget. Direkt efter
inläsning översätts de flesta taggarna till OSM-taggar, och därefter
sammanfogas det med övriga lager, låst mot referensgeometrin. I
enstaka fall görs speciell förbehandling av lagret om det behövs, till
exempel bro- och tunnellagret.

3. Samma process görs med alla lager med punktgeometri.
Punktgeometrierna läses in efter linjegeometrin eftersom de behöver
matchas mot linjegeometrin.

4. Vissa taggar kan inte översättas direkt vid inläsning, eftersom man
behöver information från flera lager samtidigt för att kunna räkna ut
OSM-taggarna. Highway-taggarna är ett exempel. Så nästa steg är att
med hjälp av all inläst information räkna ut resterande taggar.

5. Olika typer av uppstädningar av geometri och taggar, orimligt korta
segment osv.

6. Förenkling av geometri. NVDB har väldigt många punkter i sin
geometri för att göra mjuka kurvor osv. I OSM används traditionellt
inte lika många punkter, och i detta steg förenklas geometrin för att
bättre passa stilen i OSM. Det görs inte samma förenkling för alla
objekt, rondeller behåller fler punkter än landsvägar till exempel,
precis som det brukar vara i OSM.

7. Geometrin skrivs ut till OSM XML-format, och körningen är klar.

Genom hela körningen behålls koordinatsystemet i SWEREF99, det
översätts först till WGS84 när man gör OSM XML. SWEREF99 är ett bra
koordinatsystem att jobba geometrimässigt i eftersom där är XY-baserat
och 1 enhet = 1 meter.

tag_translations.py:

Översättningsfunktioner för att konvertera NVDB-taggar i varje lager
till OSM-taggar. Detta görs direkt efter ett lager laddas in, och
innan det sammanfogas med övriga lager. Regler för hur man sammanfogar
taggar finns i merge_tags.py

merge_tags.py

När lager läggs ovanpå varandra kan ibland samma taggar kollidera, och
regler för att lösa sådana situationer finns här.

process_and_resolve.py

Här är alla funktioner som förbehandlar och efterbehandlar lagren
beroende på sammanlagd information från flera lager. Exempelvis räknas
highway-taggen ut här.

nvdb_ti.py

Översättning av NVDB-tidsintervall till OSM-format. Väldigt hackigt
implementerat och inte heltäckande. Borde egentligen göras mer
generell med en tidsintervall-klass istället för en massa bollande med
strängar som nu. Men i praktiken så funkar detta, det har
kompletterats med fler fall efter hand de dyker upp i datat.

I loggen skrivs det i slutet ut en list av alla tidsintervall som
översatts, titta gärna på den och se så det ser vettigt ut. Om inte
behöver koden kompletteras med ytterligare något fall.

twodimsearch.py:

Datastruktur för olika typer av 2d-sökningar, främst att hitta punkter
som är inom ett visst avstånd. En effektiv datastruktur för detta är
ett kd-träd, men de Python-implementationer jag hittade passade inte
syftet eller var långsamma, så nu används stället ordnade träd, ett
för x och ett för y för varje x.

Att göra en optimal implementation av detta skulle snabba upp skriptet
rejält.

geometry_search.py:

Började som en generell sökstruktur för att hitta korsande linjer och
liknande, men mer specifika NVDB-funktioner har krypit in över
tiden, så den är inte längre så isolerad modul som jag skulle
önska. Från början var det tänkt att all geometri skulle matas in när
den objektet skapas, men pga små-fel i NVDB-datat har en
kompletteringsfunktion behövt läggas till i efterhand, vilket blev
lite hackigt. Men det funkar.

waydb.py:

"Databas" för NVDB-geometrin och funktioner för att sammanfoga ett
NVDB lager i taget. Databasen skapas med lagret DKReflinjetillkomst
som innehåller "all" geometri, detta används därefter som en fast
referensgeometri som de andra lagren anpassas till.

Tyvärr visade det sig att referenslagret ofta inte är 100%
i ordning. Ibland saknas vissa delar av geometrin, vissa linjer är
avhuggna osv. Därför kan geometrin numera kompletteras i
efterhand, med en lite knölig funktion (bygger på att få
kompletteringar behöver göras). Skulle man göra om det från början
skulle man antagligen designa det så att man startar med tom databas
och normalfallet är att geometrin byggs upp lager för lager.

I teorin ska alla NVDB-lager matcha referensgeometrin exakt och
vägsegment som ska sitta ihop ska verkligen sitta ihop i geometrin
osv. I praktiken är det emellertid inte så, så mycket i waydb handlar
om att snäppa punkter till referensgeometrin och få allt att sitta
ihop i slutänden. Waydb använder twodimsearch och geometry_serach till
stor del för att åstadkomma detta.

övriga filer:

Övriga filer är småfiler med hjälpfunktioner och datatyper, tämligen
uppenbart vad de är genom att öppna och titta i dem.


Övriga kommentarer
------------------

Detta avsnitt kan snabbt komma bli utdaterat, se koden. Detta gäller
första release.

I vissa fall har nya taggar som inte ännu används i OSM lagts till. Så
långt som möjligt försker de undvikas.

Här är en lista:

 - hästrastgård => amenity=horse_exercise_area sällsynt tagg för
     rastplatser
 - miljözon-klass 1/2/3 => environmental_zone:sv=1/2/3
 - beskickningsfordon => diplomatic (i samma klass som permit_holder,
     disabled etc)
 - på- eller avstigning => embark_disembark (i samma klass som
     destination, delivery etc)

Tidsintervallen använder inga custom-taggar, men ovanlig notation som
inte har fått mycket användning tidigare i Sverige.

 "vardag utom dag före sön- och helgdag" =>
   Mo-Fr <klockslag>; PH -1 day off; PH off

"PH -1 day" är ovanlig, men finns och betyder "dag för publik helgdag"
(alltså inte dag före vanliga söndagar).

Rondeller har ofta namn. I de kartor som bygger på NVDB-datat så
använder man i regel gatunamn även i rondeller, men skriptet lägger
dit rondellnamnet istället, medan gatunamnen (ofta fler än ett) hamnar
i "alt_name"-fältet.