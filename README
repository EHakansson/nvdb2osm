
Import av Trafikverkets NVDB-data till OpenStreetMap
----------------------------------------------------

Detta är README-filen till nvdb2osm.py, ett skript som konverterar
nedladdat NVDB-data (i SHP-format) till en OSM XML-fil.

Det körs på kommandoraden:

nvdb2osm.py <katalog eller zip-arkiv med NVDB shape-filer> <output.osm>

Exempel:

nvdb2osm.py -v --railway_file=Järnvägsnät_grundegenskaper.zip Luleå_kommun.zip luleå.osm

Kör kommandot utan argument för att se vilka flaggor man kan sätta. I
exemplet används "-v" för att visa INFO-loggar.

Det tar cirka en kvart att tugga igenom en kommun. Arkiven med
shape-filer laddas ner från Trafikverket. Man går till
https://lastkajen.trafikverket.se/ om man inte har ett konto finns det
knapp att registrera sig där.

Väl inne går man till Fillager->Vägdata->Kommuner/Län Shape och så
väljer man län och kommun. Det går ladda ner hela län om man vill, men
det blir orimligt mycket data att tugga på en gång.

Det går att köra skriptet direkt på zip-arkivet man laddar ner, det är
alltså inte nödvändigt att packa upp det, men även det fungerar.

Skritpet lägger inte till järnväg (järnväg kartläggs lämpligen
separat), men för att kunna lägga järnvägskorsningar på rätt position
behöver skriptet ändå det nationella järnvägsnätet. Den filen hittas
också på lastkajen:
Fillager->Järnvägsdata->Järnvägsnät_grundegenskaper.zip
Det är en fil för hela Sverige så man använder samma för alla
kommuner.

Skriptet kräver vissa tredjepartsmoduler, listade i requirements.txt,
installera med pip install -r requirements.txt

För generell Python-användning och installation får man Googla :-)


Tips för Windows 10-installation
--------------------------------

Anaconda för python gör det enklare:

    conda install geopandas
    conda install sortedcontainers
    pip install scanf


Hur importen går till
---------------------

1. Ladda ner paketerat NVDB-data från https://lastkajen.trafikverket.se/
2. Konvertera datat till OSM-format med Python-skriptet
3. Ladda in resultatet som ett eget lager i JOSM
   (dela upp det i mindre delar)
4. Ladda ner existerande OSM-karta för motsvarande område till eget
   lager i JOSM
5. Förbered existerande OSM-data för att sammanfogas med NVDB
6. Sammanfoga lagren, och ladda upp

Att ladda ner och köra det här skriptet är ett litet jobb, det stora
jobbet är att sammanfoga det manuellt med existerande. Har man inte
möjlighet/kunskap att köra Python-skript kan man kanske be någon annan
köra skripet för det område man är intresserad av för att få en
OSM-fil som man sen kan jobba med.


Bakgrund
--------

När OSM startades var det inte vanligt att det fanns publika data av
den kvalitet som finns idag i många länder. Tanken var att en stor
mängd frivilliga skulle manuellt rita alla vägar baserat på flygfoton
och egna GPS-spår.

Idag används de traditionella manuella teknikerna parallellt med att
man importerar data från olika publika databaser. Importer är
internationellt sett ett känsligt ämne, då många inom OSM fortfarande
tycker att databasen endast borde innehålla manuellt arbete gjort av
oss själva. Delvis på grund av det finns det fortfarande inga
funktioner i OSM för att använda externa datakällor och automatisk
synkronisera dessa när de uppdateras.

Det innebär att importer är fortfarande till stor del ett manuellt
arbete, och varje typ av import blir ett litet utvecklingsprojekt i
sig.

Notera att tanken med import är inte att ersätta manuellt
kartläggande, utan att vara ett komplement. Antalet kartläggare i
Sverige idag är inte tillräckligt för att hålla hela landet
uppdaterat, men genom att importera en bra bas blir arbetsuppgiften
för manuell kartläggning mer rimlig.

NVDB innehåller inte allt man vill kartlägga heller, elljusspår, olika
stigar, mm finns inte, så manuell kartläggning med lokal kännedom är
fortsatt viktig och central.


Om NVDBs precision
------------------

De flesta av våra vägar finns redan i OSM, men många är kartlagda för
många år sedan när datakällorna inte var lika bra som NVDB är, så de
är ofta värda att uppdatera. Det handlar inte bara om geometrin
(alltså vägens form), utan även annan information som
hastighetsgränser, vägbeläggning, vägnamn och flera andra "taggar" som
ofta saknas eller kan vara felaktiga i vägar som kartlagts tidigare.

NVDB-datat om än bra är inte 100% perfekt. "Värsta" exemplet är bro-
och tunneldatat som uppvisar en hel del precisionsfel, i enstaka fall
kan en bro ligga flera hundra meter fel. I andra fall handlar det mer
om hur man väljer att kartlägga vid begränsat utrymme: inne i städer
där cykelvägar och vägar kartläggs nära bredvid varandra läggs de inte
alltid exakt geografiskt utan på ett sätt som ger vägarna mer
utrymme.

NVDB-datat innehåller också flera överlapp och små glapp här och var,
vilket gör det besvärligt att jobba med maskinellt, men de flesta av
dessa småfel hanteras och repareras av importskriptet.

Hursomhelst, överlag är NVDB en mycket bra datakälla med bra
precision, så man behöver i regel inte korrigera vägarna efter
flygfoton, utan snarare tvärtom kan man använda NVDB-vägarna för att
justera flygfotons position.


Om NVDBs data-taggar
--------------------

OSM har all information i samma geometri genom att man sätter en mängd
taggar på varje väg/nod. NVDB är istället organiserat i lager med
olika information, underliggande geometri är dock
densamma. Hastighetsgränser ligger i ett lager, vägnamn i ett annat
och så vidare.

Importskriptet tar alltså alla dessa lager, översätter taggarna lager
för lager och sammanfogar. Ibland överlappar information och skripet
försöker lösa dessa situationer automatiskt, vilket går i de flesta
fall. Om inte skrivs det ut en varning och en "fixme"-tag skrivs in i
resulterande OSM-fil så man kan gå in och justera manuellt.

(NVDB:s Shape-filer (.shp) går att öppna direkt i JOSM, vilket är
användbart om man vill jämföra. JOSM gör viss geometriförenkling och
tar bort dubbletter när den öppnar en Shape-fil, så håller man på
debugga sådant behöver man analysera datat på annat vis.)

NVDB har med få undantag en hög grad av korrekthet i informationen, så
den går överlag lita på när man inte har någon bättre information.
För nybyggnationer kan datat dock vara inaktuellt och där kan det
saknas geometri, eller finnas en preliminär geometri som inte är
korrekt. Ibland kan vissa lager ha ny information och andra lager har
gammal, och då kan det bli det problem i sammanfogningen, normalt
lyckas dock skriptet tugga igenom datat ändå.

Enskild väg har inte lika rik information eftersom den inte underhålls
statligt. Vägbeläggning sägs vara grus även om vägföreningen lagt
asfalt till exempel. Inom små samhällen kan det vara tvärtom,
vägbeläggningen sägs vara asfalt fastän det är grus. I vissa
(sällsynta) fall kan vägar vara så dåligt underhållna att de inte
längre är framkomliga för bilar. Där är flygfoton och lokal kännedom
till hjälp.

Många av NVDB:s taggar går att översätta mer eller mindre rakt av till
en motsvarande OSM-tag. I vissa fall har dock NVDB mer information än
vad OSM har taggar för (till exempel fordon- och trafikanttyp), och i
andra fall har NVDB mindre information än vad OSM förväntar sig
(körfältens riktning på flerfiliga vägar och vilket av flera körfält
som är för kollektivtrafik).

I ett flertal fall finns det olika tänkbara översättningslösningar,
för att se hur skriptet gör får man läsa koden.

Det är värt att notera att NVDB inte innehåller tillräcklgit mycket
information för att göra en fullständigt bra slutledning av
highway-taggen. Highway-taggen härleds med hjälp av flera NVDB-lager
(se koden), men ändå finns inte information för att avgöra om en väg
ska vara av typen highway=service till exempel. Kora vägar fram till
sommarstugor eller bostadshus är oftast highway=track, så de får man
justera manuellt. Likaså kan inte NVDB avgöra skillnaden mellan
unclassified och track så bra, så de behöver man ofta justera, liksom
byta mellan primary/secondary/tertiary.


Kommentar om NVDB:s RLID och segmentlängd
-----------------------------------------

NVDB:s geometri har globalt unika identifierare "RLID". Dessa är
statiska och förändras inte, så man kan spåra vad som hänt med en
väg. I tidiga versioner av det här skriptet så fördes dessa
över. Vägsegmenten med ett RLID är emellertid i många fall korta,
vilket gör att vägarna blir upphuggna i små bitar. Ofta sammanfaller
det med broar, ändring av hastighetsgränser osv (som gör att det blir
uppdelning även i OSM) så i många fall blir det ändå inte fler bitar
än vad det skulle vara annars.

Testning visade dock att det är tillräckligt ofta en väg blir upphuggen
i småbitar enbart pga av RLID så därför har vi plockat bort
det. Skriptet genererar nu så långa segment som möjligt, dvs så länge
vägen inte ändrar taggar sitter det ihop i ett segment.

Trots detta blir segmenten ofta kortare än vad som finns inne i OSM nu
eftersom NVDB-skriptet har ofta högre detaljnivå (broar, ändrade
hastighetsgränser mm) som gör att taggar byts och vägarna måste delas
upp av den anledningen.

Att RLID inte förs över innebär vissa nackdelar när man ska göra
framtida uppdatering av datat. Ett uppdateringsskript måste emellertid
oavsett RLID eller ej gå in och jämföra geometrin med avancerade
algoritmer eftersom datat lever tillsammans med manuellt ritad
geometri och andra datakällor, så RLID gör inte mycket till eller från
i praktiken. I vissa specialfall hade det förvisso varit en bonus att
ha RLID kvar, men vi har gjort bedömningen att det är viktigare att
göra så långa segment som möjligt.


Tips för att sammanfoga med existerande data
--------------------------------------------

Att sammanfoga ett nytt OSM-lager som detta skript genererar med
existerande kartdata i OSM är en ganska avancerad uppgift, och det
hjälper om man är van att använda JOSM innan man försöker.

Tipsen på arbetsflöde som ges här utgår från att man går igenom "allt"
inom ett visst område. Man behöver inte uppdatera all geometri om man
inte vill förstås, man kan plocka ut mindre delar. Det handlar som
sagt dock inte bara om geometrin, NVDB-lagret innehåller väldigt
mycket taggar, hastighetsgränser, trafikförbud med tidsintervall osv
ofta mycket mer än vad som finns kartlagt sedan tidigare, åtminstone
på landsbygden. Därför kan det vara värdefullt att uppdatera vägar
även om de redan finns och ligger någorlunda rätt positionerade.

Det är också mycket vanligt att vägar kan vara väl positionerade på
en delsträcka, och på ett annat ställe längs samma väg ligger den 50
meter fel, så det kan löna sig att gå igenom hela vägsträckan.

Förbehandling:

Förbehandla översatt OSM-lager först. Gå igenom alla fixme-taggar och
kör JOSM-validatorn. Tips om detta finns under separat
rubrik. Justerande av highway-typer och liknande kan vara lättare att
göra i samband vid sammanfogningen så man ser vad som använts
tidigare.

Välj ut område att jobba i:

Vissa delar i Sverige, är redan idag mycket väl uppdaterade i
OSM. Välj ut delar som har större behov av uppdatering först, och är
du nybörjare börja med en mindre komplex geometri (landsbygd istället
för stad). I städer behöver mer förbehandling av översatt OSM-lager
göras, och det finns mer tolkning av hur kartläggning ska göras (mappa
cykelvägar separat eller ej, och hur de exakt placeras i förhållande
till intilliggande väg) och det finns mer av avancerade relationer att
ta hänsyn till (busslinjer etc) - det är helt enkelt mycket gånger
svårare att jobba med stadsgeometri än landsbygd.

Se till att du jobbar på ett ställe på kartan där ingen annan håller
på just nu. Det kan nämligen bli väldigt besvärligt om två personer
håller på och redigerar kartan på samma ställe. Använd exempelvis
history-funktionen på openstreetmap.org så kan de se var folk jobbar
just nu. Försök också jobba i mindre bitar så du kan ladda upp samma
dag som du laddade ned för att redigera, ju kortare tid mellan ned-
och uppladdning desto mindre risk för kollisioner med andras arbete.

Tyvärr finns det ingen riktigt bra funktion i OSM för att se om någon
annan redan gjort en uppdatering efter NVDB. Förr satte man
source-taggar på vägarna, men det ska man inte göra nu
längre, och changeset-source (som är där man ska ange NVDB) är bara
sökbara i 30 dagar i existerande verktyg. Det man får göra är att
visuellt inspektera. Om geometrin är lika välplacerad som NVDB, och
den är rik på taggar (hastighetsgränser, vägnamn etc) så kan man anta
att det är ett uppdaterat område.

Kontrollera positionen av existerande data:

Vissa delar av kartan är senast uppdaterad när positionsdatat i
tillgängligt källmaterial var mindre precist, man kan därför hitta
stora områden som är ganska detaljerade men som har ett offset på ett
antal tiotals meter. I vissa fall är positionsfelet så stort att man
först måste korrigera det innan man börjar arbeta med att sammanfoga,
annars kommer de exakta NDVB-vägarna gå rakt över lantbruk, sjöar och
byggnader osv. Gör då offset-korrigeringen i en separat förändring och
ladda upp innan du börjar jobba med importen.

Modifiera inte geometrin i onödan, men gör det om du måste:

För att underlätta för framtida uppdateringar av NVDB-datat så bör man
inte modifiera NVDB-geometrin om det inte är nödvändigt. Om vägarna
ändrar form blir det svårare för ett uppdateringsskript att
matcha. Ibland måste man ändra för att spegla vad som faktiskt hänt i
verkligheten och det är okej förstås. Då det gäller specifikt broar så
ligger de ofta lite fel i NVDB och då måste man ju flytta dem. Inne i
städer kan man göra flera olika korrekta val hur man lägger
vägar/cykelvägar/gångvägar intill varandra, man kanske inte vill följa
hur NVDB gör det. Det är upp till din egen bedömning hur du gör,
säkrast är förstås att behålla stilen som var innan om den var korrekt.

Välj ut en lagom stor area och sammanfoga:

Man översätter typiskt en kommun i taget med skriptet, vilket blir
för mycket att jobba med på en gång, det är oftast minst en veckas
heltidsarbete att mata in en hel kommun.

Man får dela upp lagret i JOSM, genom lite copy/paste mellan
lager. Välj en lagom stor ruta och gör select, håll in Alt-knappen så
alla väg-segment som vidrörs också blir markerade. Det lönar sig att
kopiera smart så det blir relativt få anslutande vägar in i
området.

När du är nöjd med markeringen: välj copy, sen delete, skapa nytt
lager och välj "paste at source position". Du har nu flyttat över en
liten del av lagret till ett annat lager. Det är bra att göra en kopia
av lagret ("duplicate") så du har som referens om man blandar ihop vad
som är nytt och gammalt när man håller på och sammanfogar.

Nästa steg är att laddar du ner tillräckligt mycket karta från OSM
direkt i lagret så hela är täckt. För att göra det enklare att se var
du behöver ladda ner är ett bra trick att markera allt i lagret före
du börjar ladda ner. För att göra det enklare att komma ihåg var
gränserna går utan att behöva titta på lager-kopian så kan det vara
bra att ladda ner flera mindre rutor och följa kanterna på lagret
någorlunda istället för att ladda ner onödigt mycket data
runtomkring.

Det man nu har efter nedladdning är en enda röra :-), två kartlager på
varandra, det som finns i OSM-databasen nu, plus NVDB-lagret. Det går
ta bara en väg åt gången om man känner sig mer bekväm med det, men att
ta allt på en gång på det här sättet är betydligt effektivare. Ju mer
man jobbar desto duktigare blir man på se skillnad mellan gammal och
ny geometri och det blir mindre förvirrande att jobba, men i början
kommer det kännas lite stökigt.

JOSM har en mycket bra validator som upptäcker om man har vägar som
ligger ovanpå eller nästan ovanpå varandra, det gör att det är mycket
låg risk att man glömmer jobba igenom och sammanfoga över hela
kartan. Tvärtom är det knepigare om vägar inte fanns innan, då kan man
glömma bort att justera highway-typ eftersom man inte har någon
tidigare väg att jämföra med och validatorn ger ingen varning om man
glömmer titta på den, så var uppmärksam och jobba igenom kartan
metodiskt!

Använd replace geometry för att uppdatera geometri:

Om du inte redan installerat "utilsplugin2" i JOSM så gör det, för du
behöver verktyget "replace geometry". För ett uppdatera en gammal väg
med ny NVDB-geometri, gör så här:

0. Grundprincipen att följa är att varenda segment i NVDB-vägen måste
   göras replace geometry mot ett motsvarande segment i gamla
   vägen. Om inte riskerar man att bli av med taggar som fanns i gamla
   vägen för vissa segment. I de flesta fall har gamla vägen färre
   segment (saknas broar, färre taggar osv), och då måste man dela upp
   gamla vägen i motsvarande segment.
1. Markera NVDB-vägen och se hur långt segmentet är, markera
   motsvarande segment i gamla vägen.
2. Om den gamla vägen har ett mycket längre segment (perfekt passning
   inte nödvändigt), klipp upp den. OBS: klipp av på existerande nod,
   lägger man till en ny nod fungerar inte "replace geometry".
    - Var uppmärksam när du närmar dig slutet av vägen så inte segment
      i gamla vägen tar slut innan du gjort replace geometry med alla
      NVDB-segment.
    - Om den gamla vägen istället har fler segment, dela upp
      NVDB-segmentet på motsvarande vis. Om möjligt gör join på
      vägarna efter replace geometry gjorts (dvs om taggarna är precis
      samma i båda segmenten).
       - NVDB-segmentet kan man lägga till nya noder i så den kan och
         bör delas på exakt samma ställe som den gamla vägen är,
         eftersom om gamla vägen byter taggar där måste den nya göra
         det på samma ställe.
    - Var speciellt uppmärksam på broar (och tunnlar), NVDB har
      ganska ofta precisionsproblem i placeringen av dessa så man kan
      behöva justera dem manuellt.
3. Gör replace geometry, och lös eventuella tag-konflikter i dialogen
   som kommer upp.
    - Ibland har gamla vägen en relation (större vägar har oftast
      det), dessa ska behållas.
4. Upprepa segment för segment tills hela vägen är ersatt.

"Replace geometry" gör att ersättningen av den gamla geometrin görs
med modify-operationer (dvs det ser ut som man manuellt flyttat och
lagt till noder i den gamla vägen så att den exakt matchar den
nya). Detta gör att historyn av vägsegmentet behålls vilket är viktigt
för att kunna spåra förändringar, och visar respekt mot de kartläggare
som ritat vägen innan. (Historyn hamnar dock bara på ett av segmenten
när vägen behöver delas upp, men det är så OSM fungerar, det blir
likadant med manuell kalkering.)

Om vägen man ersätter innehåller noder med taggar, som till exempel
övergångsställen och vändplaner med mera, så går det inte göra
replace. Man måste då kopiera över dessa nodtaggar. Därefter går det
att göra replace geometry som vanligt. Ofta finns noderna redan
representerade i NVDB-vägen, om det är övergångsställen till exempel,
men då det gäller exempelvis vändplaner (highway=turning_circle)
saknas de ofta i NVDB. Istället för att kopiera över taggarna kan det
gå snabbare att göra flytta noden och göra merge med motsvarande nod
på nya vägen.

Vissa import-guidelines är kritiska mot replace geometry-verktyget
eftersom en sidoeffekt blir att vägen kopplas loss från anslutande
vägar som är i gamla geometrin. Istället rekommenderar man att manuellt
kalkera från ett bakgrundslager med "improve way
accuracy"-verktyget. Här tycker vi emellertid att arbetsflödet med
replace geometry beskrivet ovan ändå är bättre för att 1) manuell
kalkering är mycket långsammare, särskilt när man dessutom ska föra
över många taggar som ofta innebär att man behöver ändra segmentlängd,
2) manuell kalkering är inte lika precis, och det blir enklare att
uppdatera i framtiden både manuellt och automatiskt om man drar nytta
av det väldigt precisa geometrin NVDB erbjuder, 3) replace geometrys
nackdel med löskoppling kompenseras av validator-verktyget som ser
till att man inte missar att koppla ihop vägar, 4) löskoppling är
mindre problem än det först verkar eftersom även anslutande geometri
uppdateras i många fall.

Var upmärksam på tidigare taggar och relationer:

I vissa fall kan det vara så att tidigare kartläggning har en högre
detaljnivå på taggningen än vad importerade datat har. Red ut dessa
efter eget omdöme, ibland kan man behöva behålla det som redan finns,
och kanske dela upp NVDB-datat i fler segment för att matcha. Följ
replace-geometry-metoden ovan så går man automatiskt igenom alla
segment.

Det här import-skriptet skapar inga relations-objekt. Busslinjer,
landsvägar, olika rutter etc finns ofta redan inlagda som relationer,
se till att dessa behålls och kopplas ihop korrekt. Genom att använda
replace geometry-arbetsflödet så sköts det automatiskt.

Hantera kanter:

När man konverterar en del i taget så kommer förstås vägar längs
kanterna på området man jobbar med vara avhuggna. Det kan vara
frestande att låta dem vara okopplade eftersom man snart ska ta in
nästa del, men för att inte hamna i en situation med en trasig karta
uppladdat till OSM se till att koppla ihop vägarna längs kanterna med
existerande vägar (om de finns). Justera de existerande vägarna
istället för NVDB-vägarna, så när man tar in nästa del passar de
ihop.

Var uppmärksam på vägtyper, modifiera vid behov:

NVDB har begränsad information för att avgöra highway-typen, och den
gör inte alltid samma beslut som är lämplig för OSM. Man behöver
således ofta ändra typ manuellt.

Validatorn är din vän:

Crossing highways, disconnected ways osv. Gå igenom varningarna
ordentligt och lär dig vad de betyder. Den är bra på att upptäcka om
du har vägdubbletter eller vägar som inte är hopkopplade. Observera
att validatorn inte upptäcker alla fel om man bara kör de tester som
körs vid uppladdning. Det är en bra start, men innan du laddar upp,
kör även validatorn på all nerladdad geometri, då hittar den fel som
finns sedan tidigare också (som man kan välja rätta till eller låta
det vara som innan), men även möjligen fler fel i din sammanfogning.

Använd OSMI (OSM inspector) efteråt:

Jobbar man med stora mängder data är det validatorn till trots ändå
viss risk att något fel slinker igenom. När leverantören geofabrik
uppdaterat sin databas (de är ganska snabba) är en bra sak att gå
igenom området man uppdaterat med deras OSM inspector:
http://tools.geofabrik.de/osmi/ då kan man hitta fel som man kanske
missade med validatorn. Routing view Islands och Unconnected roads är
det som är vettigast att gå igenom. Notera att den varnar även för
sånt som inte är verkliga fel.


FIXME-taggar och JOSM Validator
-------------------------------

Skriptet lägger till fixme-taggar där det inte klarar av att lösa en
konflikt eller där NVDB inte ger tillräckligt med information. Dessa
måste man gå igenom och lösa manuellt. Använd JOSMs sökfunktion och
sök på fixme=* för att få fram all geometri som är taggad.

När skripet körs loggar den till konsollen och skriver ut "Warning:
...." när den stöter på något problem. Det kan vara bra att titta på
dessa. Oftast resulterar en Warning i en fixme-tagg i datat så det är
inte alldeles nödvändigt att gå igenom loggen.

Man *måste* använda JOSM Validator på OSM-filen för att se vilka
problem den upptäcker, och åtgärda manuellt vid behov. I stadsmiljöer
kan det vara ganska mycket som behöver manuell justering, på
landsbyggden ibland ingenting. Bro- och tunneldatat i NVDB har en del
begränsningar och precisionsproblem, kanske saknas en cykelbro osv.

Exempel på vanliga Validator-varningar, med kommentarer:

 - Barrier=yes is unspecific:
    - Begränsad NVDB-information. Kanske kan du förbättra genom
      flygfoto
 - Crossing highways:
    - Beror ofta fel/begränsningar i NVDB:s bro- och tunneldata,
      ibland saknas broar helt och hållet osv.
 - Missing tag - street with odd number of lanes:
    - På dubbelriktad väg med fler än två filer innehåller inte NVDB
      någon information om hur många filer som går i vardera
      riktning. Det går i regel lista ut från flygfoto.
 - Stub end:
    - Skriptet städar upp stumpar genom att länka ihop segment så
      långa som möjligt och ta bort små glapp, så de som ändå blir
      kvar bör man i regel lämna orörda.
 - Suspicious tag combination oneway=yes with lanes:bus:forward:
    - Felakting varning(?), att ange riktning på lanes även om vägen
      är enkelriktad verkar vara okej enligt OSM-wiki
    - Skriptet filtrar bort onödiga forward/backward i andra fall när
      vägen är enkelriktad, men behåller på lanes.
 - Way end node near other highway:
    - Kan nästan alltid ignoreras, handlar ofta om hållplatser som
      rätteligen slutar nära en annan väg
 - Overlapping highways / highway duplicated nodes / highways with
   same position:
    - I sällsynta fall har NVDB vägar med olika RLID som ligger ovanpå
      varandra. Det är så sällsynt så skripet har ingen korrigering
      för det, om det uppstår får man laga det manuellt.
 - Suspicious roundabout direction:
    - Vissa rondeller är inte helt runda och då kan JOSM tro att de
      har felaktigt taggats som rondeller. Denna varning kan man i
      regel ignorera.


Övrigt att tänka på
-------------------

Flerfiliga vägar:

NVDB har information om antal körfält och även antal bussfält, men
inte vilket fält som är vilket. NVDB saknar även information om vilka
fält som är till för att svänga, så turn:lanes-taggning måste man göra
själv. Ofta går det se på flygfotot vilka pilar som finns i de olika
körfälten, och om inte är turn:lanes ofta kartlagt sedan tidigare så
man kan behålla det som var.

Ibland är en flerfilig väg kartlagd som en way, ibland som två och
båda sätten är korrekt (förutsatt att taggarna är rätt satta). Ibland
har NVDB och tidigare kartläggning i OSM gjort olika val. Det är upp
till din egen bedömning vad som är lämpligt i det fallet, att antingen
behålla som det är i OSM, eller det som är i NVDB. Oftast är det
vettigast att ta alternativet med fler ways eftersom vägen i dessa
fall har stor utbredning.

Stora och flerfiliga vägar ingår nästan alltid i route-relationer,
dessa måste man se till att de är korrekta efter man uppdaterat
geometrin. När man använder replace geometry och matchar segment mot
segment så sköts det automatiskt. När man gör om geometrin så att den
kanske går från en way till två, måste man manuellt uppdatera
rutterna.

Överlag är uppdatering av flerfiliga vägar en av de mer avancerade
uppgifterna i importarbetet.

Vägnummer:

I Sverige är vi vana att europavägar skrivs utan mellanslag, "E4"
istället för "E 4". För att hålla en OSM-standard över hela Europa så
genererar skriptet dock "E 4", och detta bör behållas. Länsvägar
100-499 är unika och skrivs utan länsbokstav. Länsvägar över 500 är
inte unika och därtill läggs länsbokstav (exempel "AC 1100" istället
för bara "1100"). I officiella sammanhang används länsbokstav endast
om det är nödvändigt för att undvika sammanblandning. Eftersom det ska
gå att söka i OSM-datat är det viktigt att taggar är unika därför ska
länsbokstaven vara med här.

Undernummer används sällan i olika kartor, men det finns med i OSM nu
och skriptet tar därför med dem läggs på efter huvudnumret separerat
med en punkt, exempel ("E 4.20").

Vägklass:

Skriptet använder funktionell vägklass med flera lager för att räkna
ut om en väg ska vara trunk/primary/tertiary och så vidare. På de
större vägarna stämmer det ofta överens med tidigare kartlagt, men
inte alltid. När det inte stämmer är det ofta(st) bättre att behålla
det som redan är kartlagt, även om vägens geometri kan vara kartlagd
med begränsad precision innan är typen ofta rätt.

På mindre vägar (residential/unclassified/track) saknar NVDB
detaljerad information, så där kan man behöva manuellt ändra till
service eller ändra mellan unclassified och track. För skogsvägar är
gränsen mellan unclassified och track lite knepig. Det kan finnas
anledning att nedgradera unclassified till track eller tvärtom på
vissa ställen för att bättre följa OSM-kartläggningstradition (för
skogsväg tittar funktionsklassen en del på vägkvalitet för lastbilar
osv, medan OSM tittar mer på hur mycket vägen används för vanlig
trafik).

Betraktar man lantmäteriets rasterkarta kan man ibland se att de har
mer information om småvägar än vad skriptet har, och det beror på att
rasterkartan just har mer vägklassinformation än vad som publicerats
via NVDB. Ett exempel är att rasterkartan kan göra en skogsväg
streckad, medan NVDB sätter den till unclassified som tyder på en
högre underhållsgrad. I det fallet bör man ändra till track, men kolla
flygfoto och förbindelser först, dels för att track vs unclassified
ska handla om "viktighet" snarare än kvalitet (även om det ofta
stämmer överens på småvägar), och dels för att även rasterkartan har
påfallande ofta fel för småvägar, då oftast att en väg kartläggs som
bättre än den är i verkligheten. Vill man kartlägga vägens kvalitet är
tracktype en vanligt förkommande tag, se OSM-wikin. Eftersom grade1 är
belagd så blir den i nästan aldrig använd (utom på vissa övergivna
vägar).

Finns det en tidigare väg innan ska man förstås behålla dess taggar om
man inte är säker på att man gör en bra ändring.

Vägbeläggning:

NVDB specar endast "belagd" eller "grus" för kommunala och enskilda
vägar (mer detaljerat för statligt underhållna vägar). "Grus" är ett
antagande och hamnar även på jordvägar mm, därför sätter skriptet
"surface=unpaved" för dessa vägar. För "belagd" är sannolikheten så
hög att det är någon form av asfalt att surface=asphalt används. För
kullersten mm får man således ändra manuellt.

(I OSM idag är "surface=gravel" vanlig som beteckning på grusvägar,
men enligt OSM-wiki avser det knytnävsstora stenar, så egentligen inte
rätt. Bättre är då "surface=fine_gravel".)

Vändplaner:

NVDB saknar vändplaner i skogsbilvägsnätet, så de måste man lägga till
manuellt. De syns på Lantmäteriets rasterkarta.

Vändplaner på lite större vägar finns ofta i NVDB men är så dåligt
placerade att de importeras inte av skriptet (de kartläggs i NVDB som
"vändmöjlighet" och är alltså inte en exakt specifikation var
vändplanen i fråga faktiskt ligger). Så titta gärna på flygfoton inne
byar mm där vändplaner kan förväntas finnas och lägg till vid
behov. Dessa vändplaner finns i regel inte i rasterkartan heller.

Återvändsgränder med vändplan i städer är inte heller kartlagda i
NVDB (ej heller i rasterkartan), så de får man lägga till manuellt.

Vägar som slutar med återvändsgränd eller vändplan ritas oftast lite
väl långt, till slutet av vändplanen medan OSM-tradition är att sluta
vägen mitt på vändplanen. Är man noggrann bör man matcha positionen
mot (positionsjusterat) flygfoto och det innebär i flesta fall kan man
korta av vägen något för att matcha OSM-tradition.

Parkeringar:

NVDB har inga areor, så parkering när de är kartlagda är som
punkter. För parkeringsfickor, parking=layby, rekommenderar vi starkt
att man gör det som skriptet gör, dvs endast en punkt med
parking=layby bredvid vägen. I vissa fall kan det tidigare vara
kartlagt med en area, eller en punkt med en service-vägsnutt. Om det
inte är en väldigt speciell parkeringsficka så rekommenderar vi att
man förenklar till en punkt.

För andra typer av parkeringar är dock areor att rekommendera, och
dessa måste alltså kartläggas manuellt. NVDB-skripet lägger in en nod
för större rastplatser, men dessa består i verkligheten ofta av flera
parkeringar och kanske byggnader, och är oftast redan
kartlagda. Kontrollera så att all information som NVDB-noden
tillhandahåller finns i rastplatskartläggningen, och plocka sedan bort
NVDB-noden helt om parkeringen är kartlagd som en area.

Vägbommar:

Bommar som NVDB markerat med "låst grind eller bom" sätts till
barrier=gate med access=permissive. Det betyder att bommen är
generellt sett öppen, men den kanske inte är det. Om man vet att
bommen är i regel låst kan man ändra taggen till access=private (det
finns också locked=yes, men den taggen är mindre använd).

Järnvägskorsningar:

NVDB innehåller järnvägskorsningar, men de är dåligt
positionerade. Skriptet läser in järnvägsgeometrin separat och flyttar
dem till verklig korsning, om den ligger i närheten. I enstaka fall
kan korsningen så avlägset felplacerad att skriptet inte hittar en
korsning, och då läggs en fixme-tagg till.

I fallet en väg korsar flera spår innehåller NVDB oftast bara en
korsningspunkt och istället antal spår den korsar. Skriptet duplicerar
korsningarna vid behov för att matcha. Ibland anges felaktigt antal
spår eller så saknas korsning helt och hållet (alltid(?) för
cykelväg), och då får man lägga till manuellt. Validatorn varnar om en
väg korsar en järnväg utan korsningsnod.

Själva järnvägen läggs inte till av skriptet eftersom den av tradition
kartläggs separat från vägar av kartläggare som specialiserar sig på
just järnväg.

Namn på vägar:

NVDB har skiftade kvalitet på vägnamn. Namn i städer har i regel god
kvalité, men i storleksordningen 1 av 1000 kan det vara felstavat
eller liknande, så det är bra att vara på sin vakt ändå.

Om man råkar missa något så anser vi att det är bättre att ta in
namnen oförändrade även med mindre fel som NVDB har, än att lämna
vägarna utan namn.

I vissa städer ges cykelvägarna samma namn som gatan intill, skriptet
rensar bort dessa för enligt OSM-tradition ska cykelvägarna inte ha
egna namn då. Har cykelvägen eget namn behålls det.

I vissa fall rapporteras namnen in i endast versaler. Skripet
konverterar dessa efter bästa förmåga.

Förkortningar förekommer i vägnamnen. Norra, Södra osv förkortas ofta
till en bokstav. Vi rekommenderar att man ändrar det och skriver ut
fulla namnet om man vet vad det är.

Vissa förkortningar kan man dock behålla, som Cpl för
cirkulationsplats, grv. och stv. för grenväg och stickväg.

Skogbilvägsnätet har mindre bra kvalitet på vägnamnen. Dels är det
ganska vanligt med felstavningar, och dels är det vanligt med "lat"
namngiving typ "Granträskvägen med grenvägar". Vi rekommenderar
följande strategi:

  - Korrigera stavfel
  - Ganska ofta kan namn vara anges med och utan 's', exempel
    "Storlidsvägen" eller "Storlidvägen". Om man inte har mer
    information, välj alternativet som känns mer naturligt att säga,
    (gärna i lokal dialekt) för det är i regel det namnet som används.
  - Svenska namn ska vara rikssvenska, om namnet inte är specifik känt
    för dialektstavningen. Dvs om även en person som inte talar
    dialekten använder dialektnamnet så ska dialektstavningen
    användas.
  - Vägnät som namngetts i grupp med samma namn typ "X med grenvägar"
    delas helst upp så att huvudvägen heter bara X, och grenvägarna
    heter "X grv." Skogsbilvägar förlängs ofta i omgångar så ibland är
    det inte klart vilken som är huvudväg och inte, i så fall kan det
    vara säkrast att namnge alla med samma namn, alltså bara med "X",
    och lägg inte på "med grenvägar". I många fall har NVDB redan den
    typen av namnsättning, då kan man välja behålla den eller förfina
    genom att peka ut vilka som är grenvägar genom att lägga på
    "grv.".

OSM har en tradition av att använda en del icke-officiella lokala
namn. Så ibland när man sammanfogar stöter man på ställen där namnet
på vägen kan vara ett helt annat än det som är i NVDB. Där är det upp
till din bedömning vad bästa alternativet är. Ofta är det att behålla
OSM-namnet som det är, och lägga in NVDB-namnet på alt_name.

Inne i städer är det vanligt att OSM och NVDB har oilka positioner på
exakt var namnet på en väg börjar och slutar. NVDB har oftast bra
kvalitet på sin position, så använd egen bedömning hur du gör när
skillnader uppstår.


Fel i NVDB-datat
----------------

NVDB-datat har mycket hög grad av korrekthet, men det är inte 100%
perfekt. Detta är några fel som observerats:

  - Bro-databasen har mycket fel, broarna kan vara 100 meter
    felplacerade eller för korta för att nå över älven. Broar kan
    saknas, särskilt för cykelvägar. Ungefär hälften av broarna
    behöver någon slags korrigering.
  - Broar som korsar andra vägar kan vara hopkopplade felaktigt i
    korsningen.
  - Gatunamn är i hög grad korrekt, men storleksordningen 1 av 1000
    kan vara felstavat eller liknande, för skogsbilväg mer än så.
  - I enstaka fall görs anpassning av geometrin för att ge utrymme i
    kartan, till exempel när cykelvägar går bredvid vägen inne i en
    stad kan vägen vara lagd några meter åt sidan om verkligheten.
  - I sällsynta fall (storleksordningen 1 ställe per kommun) kan en
    väg ha en liten parallelförlyttning med sväng där det egentligen
    ska vara en perfekt raksträcka.
  - Enskild väg som är belagd kan vara markerad som grus.
  - Vägar i små samhällen kan vara markerad som belagd fastän det är
    grus.
  - Original-datat har en hel del småglapp här och var, som skriptet
    reparerar för det mesta. I enstaka fall kan exempelvis en
    skogsväg sakna sitt vägnamn över 50 meter eller så. Dessa
    upptäcker man normalt under sammanfogningsprocessen så man kan
    manuellt korrigera dem.


Hålla datat uppdaterat
----------------------

NVDB är en levande databas och uppdateras hela tiden. Tanken med OSM
är att det ska finnas tillräckligt många frivilliga som håller datat
uppdaterat genom manuell kartläggning utan att behöva synka med någon
extern databas som NVDB. I praktiken finns inte så många aktiva
kartläggare i Sverige, men med NVDB inmatad i grunden finns ändå en
god chans att hålla datat fräscht på traditionellt vis - vägnätet är
ju ändå ganska statiskt. Så även om vi bara tar in NVDB-datat en gång
så lämnar i OSM-kartan i en bättre situation än den var innan.

Det finns ingen funktion i OSM för att synka automatiskt med externa
databaser, så att göra en uppdatering i framtiden skulle antagligen gå
till som så att man använder detta skript och konverterar det senaste
NVDB-datat, sen skriver man ett nytt skript som jämför detta med data
som finns inne i OSM, och därefter genererar en skillnadsfil (diff)
som man manuellt får föra över. Detta skulle man kanske göra en gång
varannat år eller så, för att komplettera sådant som kartläggare inte
hunnit uppdatera manuellt.

Detta nya skript blir troligen ganska svårt att skriva eftersom man
helst vill att det ska kunna filtrera bort justeringar i datat som
inte är faktiska förändringar utan bara förfiningar eller tillägg till
NVDB-datat, för att göra skillnadsfilen så liten som möjligt. Det är
dock inte omöjligt, särskilt med en bra grund inmatad. Det är svårare
nu i början när många av inlagda vägarna har stora offsetfel.


Information om koden
--------------------

Denna information kan bli snabbt inaktuell i och med att koden
uppdateras.

Koden är överlag ett "snabbhack", fokus på att få fram något som
fungerar så fort som möjligt snarare än att producera snygg effektiv
kod och design. Hade jag börjat om från början skulle jag troligen
försöka använda mer av shapely-biblioteket för att få effektivare
kod. Eftersom det mesta av geometriberäkningarna görs i Python-kod är
skriptet ganska långsamt.

Testning inför första release har bestått av att översätta Malmö,
Göteborg, stor-Stockholm, Umeå, Uppsala, Jokkmokk och Luleå. Även om
dessa täcker in väldigt många fall och olika typer av knepigheter i
NVDB-datat så är det troligt att skriptet kommer behöva kompletteras
ytterligare för att kunna översätta all NVDB-data i hela Sverige.

För att spara tid i bästa snabbhacksanda kör geometrikoden en massa
integritetstest på det egna datat efter förändringar, som alternativ
till en stor mängd enhetstest. Det gör att skriptet går långsammare än
det annars skulle göra. Om man orkar kan man fixa det senare (dvs ta
bort integritetstesterna och göra enhetstest på sidan om istället).

Det finns en .pylintrc så man kan köra pylint på koden.

nvdb2osm.py:

Här finns main(), alltså huvudfunktionen som kör hela processen. Grovt
sett funkar det så här:

1. Läs in ett lager med referensgeometrin och skapa en datastruktur
med denna som alla efterföljande lager matchas mot.

2. Läs in alla lager med linjegeometri, ett i taget. Direkt efter
inläsning översätts de flesta taggarna till OSM-taggar, och därefter
sammanfogas det med övriga lager, låst mot referensgeometrin. I
enstaka fall görs speciell förbehandling av lagret om det behövs, till
exempel bro- och tunnellagret.

3. Samma process görs med alla lager med punktgeometri.
Punktgeometrierna läses in efter linjegeometrin eftersom de behöver
matchas mot linjegeometrin.

4. Vissa taggar kan inte översättas direkt vid inläsning, eftersom man
behöver information från flera lager samtidigt för att kunna räkna ut
OSM-taggarna. Highway-taggarna är ett exempel. Så nästa steg är att
med hjälp av all inläst information räkna ut resterande taggar.

5. Olika typer av uppstädningar av geometri och taggar, orimligt korta
segment osv.

6. Förenkling av geometri. NVDB har väldigt många punkter i sin
geometri för att göra mjuka kurvor osv. I OSM används traditionellt
inte lika många punkter, och i detta steg förenklas geometrin för att
bättre passa stilen i OSM. Det görs inte samma förenkling för alla
objekt, rondeller behåller fler punkter än landsvägar till exempel,
precis som det brukar vara i OSM.

7. Geometrin skrivs ut till OSM XML-format, och körningen är klar.

Genom hela körningen behålls koordinatsystemet i SWEREF99, det
översätts först till WGS84 när man gör OSM XML. SWEREF99 är ett bra
koordinatsystem att jobba geometrimässigt i eftersom där är XY-baserat
och 1 enhet = 1 meter.

tag_translations.py:

Översättningsfunktioner för att konvertera NVDB-taggar i varje lager
till OSM-taggar. Detta görs direkt efter ett lager laddas in, och
innan det sammanfogas med övriga lager. Regler för hur man sammanfogar
taggar finns i merge_tags.py

merge_tags.py

När lager läggs ovanpå varandra kan ibland samma taggar kollidera, och
regler för att lösa sådana situationer finns här.

process_and_resolve.py

Här är alla funktioner som förbehandlar och efterbehandlar lagren
beroende på sammanlagd information från flera lager. Exempelvis räknas
highway-taggen ut här.

nvdb_ti.py

Översättning av NVDB-tidsintervall till OSM-format. Väldigt hackigt
implementerat och inte heltäckande. Borde egentligen göras mer
generell med en tidsintervall-klass istället för en massa bollande med
strängar som nu. Men i praktiken så funkar detta, det har
kompletterats med fler fall efter hand de dyker upp i datat.

I loggen skrivs det i slutet ut en list av alla tidsintervall som
översatts, titta gärna på den och se så det ser vettigt ut. Om inte
behöver koden kompletteras med ytterligare något fall.

twodimsearch.py:

Datastruktur för olika typer av 2d-sökningar, främst att hitta punkter
som är inom ett visst avstånd. En effektiv datastruktur för detta är
ett kd-träd, men de Python-implementationer jag hittade passade inte
syftet eller var långsamma, så nu används stället ordnade träd, ett
för x och ett för y för varje x.

Att göra en optimal implementation av detta skulle snabba upp skriptet
rejält.

geometry_search.py:

Började som en generell sökstruktur för att hitta korsande linjer och
liknande, men mer specifika NVDB-funktioner har krypit in över
tiden, så den är inte längre så isolerad modul som jag skulle
önska. Från början var det tänkt att all geometri skulle matas in när
den objektet skapas, men pga små-fel i NVDB-datat har en
kompletteringsfunktion behövt läggas till i efterhand, vilket blev
lite hackigt. Men det funkar.

waydb.py:

"Databas" för NVDB-geometrin och funktioner för att sammanfoga ett
NVDB lager i taget. Databasen skapas med lagret DKReflinjetillkomst
som innehåller "all" geometri, detta används därefter som en fast
referensgeometri som de andra lagren anpassas till.

Tyvärr visade det sig att referenslagret ofta inte är 100%
i ordning. Ibland saknas vissa delar av geometrin, vissa linjer är
avhuggna osv. Därför kan geometrin numera kompletteras i
efterhand, med en lite knölig funktion (bygger på att få
kompletteringar behöver göras). Skulle man göra om det från början
skulle man antagligen designa det så att man startar med tom databas
och normalfallet är att geometrin byggs upp lager för lager.

I teorin ska alla NVDB-lager matcha referensgeometrin exakt och
vägsegment som ska sitta ihop ska verkligen sitta ihop i geometrin
osv. I praktiken är det emellertid inte så, så mycket i waydb handlar
om att snäppa punkter till referensgeometrin och få allt att sitta
ihop i slutänden. Waydb använder twodimsearch och geometry_serach till
stor del för att åstadkomma detta.

övriga filer:

Övriga filer är småfiler med hjälpfunktioner och datatyper, tämligen
uppenbart vad de är genom att öppna och titta i dem.


Övriga kommentarer
------------------

Detta avsnitt kan snabbt komma bli utdaterat, se koden. Detta gäller
första release.

I vissa fall har nya taggar som inte ännu används i OSM lagts till. Så
långt som möjligt försker de undvikas.

Här är en lista:

 - hästrastgård => amenity=horse_exercise_area sällsynt tagg för
     rastplatser
 - miljözon-klass 1/2/3 => environmental_zone:sv=1/2/3
 - beskickningsfordon => diplomatic (i samma klass som permit_holder,
     disabled etc)
 - på- eller avstigning => embark_disembark (i samma klass som
     destination, delivery etc)

Tidsintervallen använder inga custom-taggar, men ovanlig notation som
inte har fått mycket användning tidigare i Sverige.

 "vardag utom dag före sön- och helgdag" =>
   Mo-Fr <klockslag>; PH -1 day off; PH off

"PH -1 day" är ovanlig, men finns och betyder "dag för publik helgdag"
(alltså inte dag före vanliga söndagar).

Rondeller har ofta namn. I de kartor som bygger på NVDB-datat så
använder man i regel gatunamn även i rondeller, men skriptet lägger
dit rondellnamnet istället, medan gatunamnen (ofta fler än ett) hamnar
i "alt_name"-fältet.